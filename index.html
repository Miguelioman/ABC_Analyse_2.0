<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>ABC Analyse Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  .hidden { display: none; }
  h2 { margin-top: 30px; }
  table { border-collapse: collapse; width: 100%; margin-top: 10px; }
  th, td { border: 1px solid #ccc; padding: 6px; text-align: left; }
  th { background: #eee; cursor: pointer; }
  .filter-container { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
  #monthsOverview { margin-top: 10px; font-weight: bold; }
  .chart-container { width: 600px; max-width: 100%; margin-top: 20px; }
  #uploadBtn {
    background-color: #007bff; color: white; padding: 8px 16px;
    border: none; border-radius: 4px; cursor: pointer;
  }
  #uploadBtn:hover { background-color: #0056b3; }
</style>
</head>
<body>

<h1>ABC Analyse Dashboard</h1>
<p>Upload Ã©Ã©n Excelbestand met meerdere maand-sheets (sheetnaam = maand, bijv. 02-2025, 03-2025, etc.).</p>

<button id="uploadBtn" type="button">Upload en verwerk Excel</button>
<input type="file" id="excelFile" accept=".xlsx,.xls" style="display:none">

<div id="monthsOverview"></div>

<div id="mainContent" class="hidden">
  <h2>Hoofdoverzicht</h2>
  <div class="filter-container">
    <label>Filter producttype:
      <select id="filterType"><option value="">Alle</option></select>
    </label>
    <label>Filter categorie (laatste maand):
      <select id="filterCat">
        <option value="">Alle</option>
        <option value="A">A</option>
        <option value="B">B</option>
        <option value="C">C</option>
      </select>
    </label>
    <label>Op voorraad (laatste maand):
      <select id="filterStock">
        <option value="">Alle</option>
        <option value="ja">Ja</option>
        <option value="nee">Nee</option>
      </select>
    </label>
    <label>Zoek: <input type="text" id="searchInput" placeholder="Zoek op productnaam"></label>
  </div>
  <table id="mainTable"></table>

  <h2>Top/Bottom verkopers (instelbaar)</h2>
  <div class="filter-container">
    <label>Aantal: <input type="number" id="topCount" value="10" min="1" style="width:80px"></label>
    <label>Weergave:
      <select id="topBottomSelect">
        <option value="top">Top</option>
        <option value="bottom">Bottom</option>
      </select>
    </label>
    <label>Filter producttype:
      <select id="filterTypeTop"><option value="">Alle</option></select>
    </label>
    <label>Op voorraad (laatste maand):
      <select id="filterStockTop">
        <option value="">Alle</option>
        <option value="ja">Ja</option>
        <option value="nee">Nee</option>
      </select>
    </label>
  </div>
  <table id="topBottomTable"></table>

  <h2>Charts</h2>
  <label>Filter producttype:
    <select id="filterTypeChart"><option value="">Alle</option></select>
  </label>
  <div class="chart-container">
    <canvas id="pieChart"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="trendChart"></canvas>
  </div>
</div>

<script>
let allData = {};           // { '02-2025': [ {title, Producttype, Verkocht, OpVoorraad, Categorie} ] }
let months = [];            // oplopend gesorteerd
let productHistory = {};    // per product: { type, stock, cats[per maand], avgScore, soldLast, catLast }
let charts = { pie: null, trend: null };

// === Upload-knop ===
document.getElementById("uploadBtn").addEventListener("click", () => {
  document.getElementById("excelFile").click();
});
document.getElementById("excelFile").addEventListener("change", handleExcelUpload);

// === Inlezen Excel ===
function handleExcelUpload(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    const workbook = XLSX.read(e.target.result, { type: 'binary' });
    months = [];
    allData = {};
    productHistory = {};

    workbook.SheetNames.forEach(sheetName => {
      const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
      if (rows.length) {
        const m = sheetName.trim();
        months.push(m);
        allData[m] = processMonthSheet(rows); // 1 categorie per product per maand
      }
    });

    // sorteer maanden oplopend (02-2025, 03-2025, ...)
    months.sort((a,b) => {
      const [ma, ya] = a.split('-').map(Number);
      const [mb, yb] = b.split('-').map(Number);
      return ya === yb ? ma - mb : ya - yb;
    });

    buildProductHistory(); // maakt beloop & score, en velden van laatste maand
    document.getElementById("monthsOverview").textContent =
      "ðŸ“… GeÃ¯mporteerde maanden: " + months.join(', ');
    document.getElementById("mainContent").classList.remove("hidden");

    fillProductTypeFilters();
    buildMainTable();
    buildTopBottomTable();
    buildCharts();
  };
  reader.readAsBinaryString(file);
}

// === Helpers & verwerking ===
function normalizeType(type) {
  if (!type) return '';
  return type.toString().trim().toLowerCase().replace(/\s+/g, ' ')
             .replace(/(^|\s)\S/g, l => l.toUpperCase());
}

/**
 * Verwerk Ã©Ã©n sheet (maand):
 * - Aggregeer op Product title (soms meerdere varianten)
 * - Bereken ABC op basis van totaal Verkocht per product
 * - Geef exact 1 rij per product terug
 */
function processMonthSheet(rows) {
  const byTitle = {};
  rows.forEach(row => {
    const title  = (row["Product title"] || "").toString();
    if (!title) return;

    const type   = normalizeType(row["Product type"]);
    const sold   = Number(row["Inventory units sold"]) || 0;
    const endInv = Number(row["Ending inventory units"]) || 0;

    if (!byTitle[title]) {
      byTitle[title] = {
        title,
        Producttype: type,
        Verkocht: 0,
        EndInv: 0
      };
    }
    byTitle[title].Verkocht += sold;
    byTitle[title].EndInv    += endInv;
    // Als het type leeg was, overschrijf met laatste bekende
    if (!byTitle[title].Producttype && type) byTitle[title].Producttype = type;
  });

  // Bereken ABC per maand
  const list = Object.values(byTitle);
  list.sort((a,b) => b.Verkocht - a.Verkocht);
  const total = list.reduce((s,r) => s + r.Verkocht, 0);
  let cum = 0;
  list.forEach(r => {
    cum += r.Verkocht;
    const pct = total > 0 ? (cum / total) * 100 : 0;
    r.Categorie  = pct <= 80 ? 'A' : pct <= 95 ? 'B' : 'C';
    r.OpVoorraad = r.EndInv > 0 ? 'ja' : 'nee';
  });
  return list;
}

// Bouw per product het beloop (A/B/C per maand in *exact* dezelfde volgorde als months)
function buildProductHistory() {
  // Index per maand op producttitel
  const indexByMonth = {};
  const allTitles = new Set();
  months.forEach(m => {
    const map = {};
    allData[m].forEach(r => { map[r.title] = r; allTitles.add(r.title); });
    indexByMonth[m] = map;
  });

  const lastMonth = months[months.length - 1];
  productHistory = {};

  allTitles.forEach(title => {
    // precies Ã©Ã©n letter per maand (of '-')
    const cats = months.map(m => {
      const row = indexByMonth[m][title];
      return row ? row.Categorie : '-';
    });

    // Gemiddelde score over aanwezige maanden (A=1, B=2, C=3)
    const scores = cats
      .filter(c => c === 'A' || c === 'B' || c === 'C')
      .map(c => c === 'A' ? 1 : (c === 'B' ? 2 : 3));
    const avg = scores.length ? (scores.reduce((a,b)=>a+b,0) / scores.length) : null;

    // Velden laatste maand
    const lastRow = indexByMonth[lastMonth][title] || null;
    let type = '';
    if (lastRow) {
      type = lastRow.Producttype;
    } else {
      // fallback: meest recente maand waar het product wÃ©l voorkomt
      for (let i = months.length - 1; i >= 0; i--) {
        const r = indexByMonth[months[i]][title];
        if (r) { type = r.Producttype; break; }
      }
    }

    productHistory[title] = {
      type,
      stock: lastRow ? lastRow.OpVoorraad : '',
      soldLast: lastRow ? lastRow.Verkocht : 0,
      catLast: cats[cats.length - 1],
      cats,                       // lengte = months.length
      avgScore: avg
    };
  });
}

// === Tabel Hoofdoverzicht ===
function buildMainTable() {
  const table = document.getElementById("mainTable");
  const filterType  = document.getElementById("filterType").value;
  const filterCat   = document.getElementById("filterCat").value;   // laatste maand
  const filterStock = document.getElementById("filterStock").value; // laatste maand
  const q = document.getElementById("searchInput").value.toLowerCase();

  let rows = Object.keys(productHistory).map(title => ({
    title,
    type: productHistory[title].type,
    catLast: productHistory[title].catLast,
    beloop: productHistory[title].cats.join(''), // exact #months letters (of '-')
    avgScore: productHistory[title].avgScore != null ? productHistory[title].avgScore.toFixed(2) : '',
    stock: productHistory[title].stock,
    soldLast: productHistory[title].soldLast
  }));

  if (filterType)  rows = rows.filter(r => r.type === filterType);
  if (filterCat)   rows = rows.filter(r => r.catLast === filterCat);
  if (filterStock) rows = rows.filter(r => r.stock === filterStock);
  if (q)           rows = rows.filter(r => r.title.toLowerCase().includes(q));

  let html = `
    <tr>
      <th>Product</th>
      <th>Type</th>
      <th>Categorie (laatste maand)</th>
      <th>Beloop (${months.length} mnd)</th>
      <th>Gem. Score</th>
      <th>Op voorraad (laatste)</th>
      <th>Verkocht (laatste)</th>
    </tr>`;
  rows.forEach(r => {
    html += `<tr>
      <td>${r.title}</td>
      <td>${r.type}</td>
      <td>${r.catLast}</td>
      <td>${r.beloop}</td>
      <td>${r.avgScore}</td>
      <td>${r.stock}</td>
      <td>${r.soldLast}</td>
    </tr>`;
  });
  table.innerHTML = html;
  makeTableSortable(table);
}

// === Tabel Top/Bottom === (t.o.v. verkochte aantallen in laatste maand)
function buildTopBottomTable() {
  const table = document.getElementById("topBottomTable");
  const count       = parseInt(document.getElementById("topCount").value) || 10;
  const mode        = document.getElementById("topBottomSelect").value;
  const filterType  = document.getElementById("filterTypeTop").value;
  const filterStock = document.getElementById("filterStockTop").value;

  let rows = Object.keys(productHistory).map(title => ({
    title,
    type: productHistory[title].type,
    beloop: productHistory[title].cats.join(''),
    avgScore: productHistory[title].avgScore != null ? productHistory[title].avgScore.toFixed(2) : '',
    soldLast: productHistory[title].soldLast,
    stock: productHistory[title].stock
  }));

  if (filterType)  rows = rows.filter(r => r.type === filterType);
  if (filterStock) rows = rows.filter(r => r.stock === filterStock);

  rows.sort((a,b) => mode === "top" ? b.soldLast - a.soldLast : a.soldLast - b.soldLast);
  rows = rows.slice(0, count);

  let html = `
    <tr>
      <th>Product</th>
      <th>Type</th>
      <th>Beloop (${months.length} mnd)</th>
      <th>Gem. Score</th>
      <th>Verkocht (laatste)</th>
    </tr>`;
  rows.forEach(r => {
    html += `<tr>
      <td>${r.title}</td>
      <td>${r.type}</td>
      <td>${r.beloop}</td>
      <td>${r.avgScore}</td>
      <td>${r.soldLast}</td>
    </tr>`;
  });
  table.innerHTML = html;
  makeTableSortable(table);
}

// === Grafieken ===
function buildCharts() {
  const filterType = document.getElementById("filterTypeChart").value;

  // ABC verdeling (laatste maand, optioneel gefilterd op type)
  const lastMonth = months[months.length - 1];
  const rowsLast = filterType
    ? allData[lastMonth].filter(r => r.Producttype === filterType)
    : allData[lastMonth];

  const catCount = {A:0, B:0, C:0};
  rowsLast.forEach(r => { catCount[r.Categorie]++; });

  if (charts.pie) charts.pie.destroy();
  charts.pie = new Chart(document.getElementById("pieChart"), {
    type: 'pie',
    data: {
      labels: ['A','B','C'],
      datasets: [{ data: [catCount.A, catCount.B, catCount.C],
                   backgroundColor: ['#4caf50','#ff9800','#f44336'] }]
    }
  });

  // Trend (totale verkoop per maand)
  const monthSales = {};
  months.forEach(m => monthSales[m] = allData[m].reduce((s,r)=>s+r.Verkocht,0));

  if (charts.trend) charts.trend.destroy();
  charts.trend = new Chart(document.getElementById("trendChart"), {
    type: 'line',
    data: {
      labels: months,
      datasets: [{
        label: 'Totale verkoop',
        data: months.map(m => monthSales[m]),
        fill: false,
        borderColor: 'blue'
      }]
    }
  });
}

// === Filters ===
function fillProductTypeFilters() {
  const types = new Set(Object.values(productHistory).map(p => p.type).filter(Boolean));
  const sorted = [...types].sort();
  ['filterType','filterTypeTop','filterTypeChart'].forEach(id => {
    const sel = document.getElementById(id);
    sel.innerHTML = '<option value="">Alle</option>';
    sorted.forEach(t => sel.innerHTML += `<option value="${t}">${t}</option>`);
  });
}

// === Sorteerbare tabellen (alle kolommen) ===
function makeTableSortable(table) {
  const headers = table.querySelectorAll("th");
  headers.forEach((th, idx) => {
    th.addEventListener("click", () => {
      const rows = Array.from(table.querySelectorAll("tr")).slice(1);
      const asc = !th.classList.contains("asc"); // toggle
      headers.forEach(h => h.classList.remove("asc","desc"));
      th.classList.add(asc ? "asc" : "desc");

      rows.sort((a,b) => {
        const A = a.children[idx].innerText.trim();
        const B = b.children[idx].innerText.trim();

        const numA = A === '' ? NaN : Number(A.replace(',', '.'));
        const numB = B === '' ? NaN : Number(B.replace(',', '.'));

        if (!isNaN(numA) && !isNaN(numB)) return asc ? (numA - numB) : (numB - numA);
        return asc ? A.localeCompare(B) : B.localeCompare(A);
      });
      rows.forEach(r => table.appendChild(r));
    });
  });
}

// Rebuild bij filterwijziging
['filterType','filterCat','filterStock','searchInput'].forEach(id => {
  document.getElementById(id).addEventListener('input', buildMainTable);
});
['topCount','topBottomSelect','filterTypeTop','filterStockTop'].forEach(id => {
  document.getElementById(id).addEventListener('input', buildTopBottomTable);
});
document.getElementById('filterTypeChart').addEventListener('input', buildCharts);
</script>

</body>
</html>
